厳格改善要求レポート for  lib/core/utils/

firestore_retry.dart

セクションA：厳格改善要求レポート (技術監査)

1. UI（ユーザーインターフェース）改善レポート

このユーティリティクラスはFirestore操作のリトライや競合解決のためのバックエンドロジックであり、UI

コンポーネントは含まれていません。そのためUI観点での指摘はありません。

2. UX（ユーザーエクスペリエンス）改善レポート

FirestoreRetryUtil自体はユーザーインターフェースを持ちませんが、操作遅延やリトライ処理がUXに影響し

ます。

• 

問題点 [UXF-003]: リトライ処理中にUIへのフィードバックが行われないため、ユーザーが長時間待

機している理由を理解できない。

• 

重大度: 中

• 

場所: リトライ処理全般（ execute / getWithRetry / updateWithRetry 等）

• 

最悪のシナリオ: 通信状況が悪い場合に何度もリトライが走り、アプリが反応していないように見えて

ユーザーが離脱する。

• 

具体的改善案: リトライ回数や次回リトライまでの待ち時間をコールバックでUI側に通知するように

する。例えば onRetry(int attempt, Duration delay) 引数を追加し、UI側でローディングインジ

ケータにメッセージを表示できるようにする。

3. パフォーマンス改善レポート (ボトルネック特定)

• 

問題点 [PERF-003]: print ステートメントを使用してリトライ情報を出力しているため、本番環境

ではログが溢れパフォーマンスと可観測性を損なう。

• 

重大度: 中

• 

場所: 1"> firestore_retry.dart  108行目

• 

最悪のシナリオ: 多数のクライアントで同時にリトライが発生した場合、標準出力のI/O負荷が高まり

アプリのレスポンスが低下する。

• 

具体的改善案:

logger パッケージや FirebaseCrashlytics 等を用いてログレベルを環境毎に制御す

る。開発環境では詳細ログを出力し、本番環境では警告以上のみを記録する。

• 

問題点 [PERF-004]: ジッター付き指数バックオフの計算で Random() を毎回インスタンス化し、 pow

関数を多用している。

• 

重大度: 低

• 

場所: 2"> firestore_retry.dart  140–165行目

• 

最悪のシナリオ: 大量のリトライが発生した場合にCPU負荷がやや増大する。

• 

具体的改善案: Random をクラスレベルで一度だけ生成し再利用する。また、 pow を用いずビット演

算や左シフト演算で指数的増加を計算することで軽量化する。

1

4. アーキテクチャ・コード品質改善レポート

• 

問題点 [CODE-004]: RetryUtil は静的メソッドを多用しており、依存性注入が困難でテストが難し

い。

• 

重大度: 中

• 

場所: 全体

• 

最悪のシナリオ: テスト時にリトライ処理をモックできず、ネットワーク環境に依存した不安定なテ

ストとなる。

• 

具体的改善案:

RetryUtil をクラスとしてインスタンス化し、 ILogger や Random をコンストラクタ

インジェクションする。これによりユニットテストで依存を差し替え可能になる。

• 

問題点  

[CODE-005]:  競合解決ユーティリティ ConflictResolver における updateFunction が

dynamic や Map<String, dynamic> を返す設計となっており型安全性が低い。

• 

重大度: 中

• 

場所: 3"> firestore_retry.dart  200–290行目

• 

最悪のシナリオ: 不適切な型のデータを返してしまい、ランタイム時にエラーが発生する可能性があ

る。

• 

具体的改善案: ジェネリクスを使用して ConflictResolver の戻り値の型を制約し、呼び出し側で型推

論が働くようにする。また、 updateFunction の引数も具象型を受け取るようにすることで型安全性

を強化する。

5. セキュリティ脆弱性レポート

• 

問題点 [SEC-004]: リトライ可能なエラーかどうかを判定する際にエラーコードの文字列を直接比較

しているが、この一覧が最新のFirebaseエラーコードに追従していない。

• 

重大度: 低

• 

場所: 4"> firestore_retry.dart  120–128行目

• 

最悪のシナリオ: 新しく追加されたエラーコードをリトライ対象外としてしまい、永続的にエラーが

発生する。

• 

具体的改善案: Firebaseの公式ドキュメントに基づき定期的にリトライ対象コードを更新する。

shouldRetry のデフォルト実装を外部から差し替えられるようにして、アプリ側で最新のエラーコー

ドを指定できるようにする。

6. 国際化 (i18n) 対応準備レポート

このクラスはユーザーに直接表示するメッセージを持たないためi18nの対象外です。ただし、今後追加され

るエラー文言はすべて外部化する必要があります。

2

セクションB：生成タスク (QA・ドキュメント)

7. 優先度付き改善タスクリスト（バックログ形式）

優先度

指摘ID

タスク概要

推定工

数（人

日）

RetryUtil および ConflictResolver をインスタ

[CODE-004]

ンス化可能なクラスにリファクタリングし、依存

2.0

性注入を可能にする

担当推奨

Backend,

Arch

[PERF-003]

print の削除とロギング基盤への移行

0.5

Backend

[UXF-003]

リトライ情報をUIに通知できるコールバック追加 1.0

Backend、

App

[PERF-004]

バックオフ計算のパフォーマンス改善（ Random

インスタンスの再利用、ビット演算化）

1.0

Backend

[CODE-005]

ConflictResolver にジェネリクスを導入し型安

全性を向上させる

1.5

Backend

[SEC-004]

Firebaseエラーコード一覧の更新と設定の外部化

0.5

Backend

P0 (即

時対

応)

P1 (今

週中)

P1 (今

週中)

P2 (次

スプリ

ント)

P2 (次

スプリ

ント)

P3 (将

来的)

8. 不足ドキュメント（README.md 追記案）

firestore_retry.dart   の使用方法やリトライ戦略設定がREADMEに記載されていません。次の内容を追記

することで開発者が適切に利用できるようになります。

## 

 Firestoreリトライユーティリティ

### リトライの使い方

* 任意の非同期操作をリトライ付きで実行するには、`RetryUtil.execute(action: () async { ... }, 
config: RetryConfig(...))` を使用してください。リトライ回数や遅延戦略は `RetryConfig` で設定

できます。

* Firestore `DocumentReference` や `Query` には `getWithRetry`, `updateWithRetry`, 

`setWithRetry`, `deleteWithRetry` などの拡張メソッドが用意されています。これらはデフォルト設

定（最大3回、指数バックオフ＋ジッター）でリトライを行います。

### 競合解決

* トランザクションによる競合解決は `ConflictResolver.resolveWithTransaction` を使用します。

`updateFunction` にドキュメントから新しいデータを生成する処理を記述してください。

* 楽観的ロックやカスタムマージもサポートしています。ドキュメントのバージョン管理を行う際は

`version`フィールドを用意し、更新毎にインクリメントしてください。

3

### ベストプラクティス

* 多量の書き込みを行う場合は `BatchWriteWithRetry` の `executeLarge` を使用し、500件ごとに分

割して書き込みます。レート制限を避けるためバッチ間に待機時間を設けています。

* 本番環境ではリトライ時に`print`ではなく適切なロギング（例: `logger`パッケージ）を使用し、不

要なログ出力を抑制します。

1

2

3

4

firestore_retry.dart

https://github.com/neko-jpg/MinQ/blob/feat-improve/lib/core/utils/firestore_retry.dart

4

